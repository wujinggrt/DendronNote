---
id: b39d63z2tzabq02crllj1bg
title: 批处理与字符匹配替换_宏和寄存器等
desc: ''
updated: 1752247633056
created: 1740302185257
---

## Register：保存拷贝、删除的内容，还有宏保存的指令

查看寄存器：普通模式下，使用命令：`:reg`。

命令行下插入光标单词：普通模式使用 `:` 激活命令行后，`<C-r><C-w>` 把光标内容插到命令行提示中。

### 保存到寄存器

普通模式下，复制操作命令 `y` 保存内容到寄存器 `"` 和 `0`。而删除或更改操作 `x` `d`, `c` 保存到寄存器 `"` 和 `1` 到 `9`，滚动式地更新。可以看到，`"` 涉及 `yxdc` 都会改变，而 `0` 和 `1-9` 则有对应的操作。猜测，也许是因为滚动，vim 从中 undo。

`0` 是“安全复制寄存器”，不受删除操作影响。`1-9` 是删除历史寄存器，按操作顺序滚动更新。

指定保存的寄存器，先使用 `"<寄存器标识>`，再用 `yxdc` 其中之一，内容会保存到指定寄存器。普通模式和 visual 模式操作一致。

### 从寄存器中粘贴

指定保存的寄存器，先使用 `"<寄存器标识>`，再用 `p` 或 `P` 粘贴寄存器内容。可以总结，操作指定寄存器，使用 `"<reg#>` 即可。

插入模式下，使用 `<C-r><寄存器标识>`，比如 `<C-r>q` 将寄存器 `"q` 的内容粘贴。

## Macro：批量操作
Vim 中，宏可以记录用户的一组命令，并批量应用到多个位置或文件。

使用 `q<寄存器名>` 录制宏，后续按键操作记录到寄存器，再次按 `q` 停止。

输入 `@<寄存器名>` 播放宏，`@@` 使用上一次的宏。可以输入调用数量，比如 `5@a` 执行 5 次记录在寄存器 a 的宏。

如果需要将宏应用在选定区域的每一行，操作如下：
1. 选择 `V` 进入 visual 模式，后续选择多行即可
2. 进入命令模式，输入 `:` 时， 会自动出现 `:'<,'>`，代表正对选中区域操作。再输入 `normal @a`，可以看到最终输入 `:normal @a`，将寄存器 a 的宏应用到选中区域每一行

`normal` 代表执行普通模式下的操作。

### 查看宏

宏保存在寄存器中，可以用 `:reg` 查看所有寄存器的值，找到对应的即可。或直接查看单个寄存器，比如 q，`:reg q`。

### 例子

```cpp
    __device__ static void wgmma(uint64_t const& desc_a, uint64_t const& desc_b, float* d, bool scale_d) {
        wgmma(desc_a, desc_b,
              d[0], d[0], d[0], d[0], d[0], d[0], d[0], d[0],
              d[0], d[0], d[0], d[0], d[0], d[0], d[0], d[0],
              d[0], d[0], d[0], d[0], d[0], d[0], d[0], d[0],
              d[0], d[0], d[0], d[0], d[0], d[0], d[0], d[0],
              d[0], d[0], d[0], d[0], d[0], d[0], d[0], d[0],
              d[0], d[0], d[0], d[0], d[0], d[0], d[0], d[0],
              scale_d);
    }
```

修改方括号的数字，将上面的代码编辑为下面的。

```cpp
    __device__ static void wgmma(uint64_t const& desc_a, uint64_t const& desc_b, float* d, bool scale_d) {
        wgmma(desc_a, desc_b,
              d[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7],
              d[8], d[9], d[10], d[11], d[12], d[13], d[14], d[15],
              d[16], d[17], d[18], d[19], d[20], d[21], d[22], d[23],
              d[24], d[25], d[26], d[27], d[28], d[29], d[30], d[31],
              d[32], d[33], d[34], d[35], d[36], d[37], d[38], d[39],
              d[40], d[41], d[42], d[43], d[44], d[45], d[46], d[47],
              scale_d);
    }
```

```cpp
    __device__ static void wgmma(uint64_t const& desc_a, uint64_t const& desc_b, float* d, bool scale_d) {
        wgmma(desc_a, desc_b,
              d[0], d[0], d[0], d[0], d[0], d[0], d[0], d[0],
              d[0], d[0], d[0], d[0], d[0], d[0], d[0], d[0],
              d[0], d[0], d[0], d[0], d[0], d[0], d[0], d[0],
              d[0], d[0], d[0], d[0], d[0], d[0], d[0], d[0],
              d[0], d[0], d[0], d[0], d[0], d[0], d[0], d[0],
              d[0], d[0], d[0], d[0], d[0], d[0], d[0], d[0],
              scale_d);
    }
```

## 字符串统计与替换

### 匹配与 RE

元字符：`^ $. * + {} [] () | \`

使用 `/` 可以激活查询，随后输入如形式 `/{{pattern}}`，查找模式匹配的内容。可以用正则，配合元字符增强表达能力。比如 `:/foo\(1|2\) ` 可以匹配 `foo1` 或 `foo2`。

可以看到，括号需要配合 `\` 使用。因为最初的设计中，普通括号 `()` 被视为字面字符。分组功能是通过转义形式 `\(\)` 实现的。其他元字符可以不用 `\` 转义。

可以在匹配前使用：
- `\v`，very magic：任何元字符前不用加上 `\`，即可传给正则引擎。比如 `/\v(ABC|DCC)`
- `\V`，very nomagic，大写通常表示反义：任何元字符前都要加上 `\`，才能传给正则引擎。比如 `/\V\(ABC|DCC\)`

在匹配和替换时，可以使用正则，也可以使用 `\v` 和 `\V` 选项。

`&` 代表匹配的内容。


#### 统计 pattern 出现次数

```vim
:%s/{{pattern}}//gn
```

% 表示全文本，s 表示替换，`//` 表示无替换文本，g 代表处理单行中所有 pattern，n 代表报告匹配数量，并且不执行替换。

### 替换：sed 功能

选中后，使用命令 `:'<,'>g/^\s*$/d` 删除空白行。

VS Code 的 Vim 插件没有实现 g

### 实践

#### 删除空行

删除选中区域空行：`/^\s*$/d`。VS Code 的 Vim 插件使用命令 :'<,'>g/^\s*$/d 会提示 E488: Trailing characters，所以 VS Code 使用原生的命令来实现：

```json
    {
      "before": [
        "<leader>",
        "d"
      ],
      "commands": [
        {
          // 删除选中空白行
          "command": "editor.action.insertSnippet",
          "args": {
            "snippet": "${TM_SELECTED_TEXT/^\\s*$(\\r?\\n)?//gm}"
          }
        }
      ]
    },
```

#### 给英文字符与 ` 周围添加空格，与中文添加空格

```
:'<,'>s/([0-9a-z`]+|`.*?`)/ & /g
```

## Ref and Tag

#Vim
#Utils