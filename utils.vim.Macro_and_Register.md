---
id: b39d63z2tzabq02crllj1bg
title: Macro_and_Register
desc: ''
updated: 1745688800582
created: 1740302185257
---

## Register：保存拷贝、删除的内容，还有宏保存的指令


普通模式下，使用命令查看：`:reg`。

普通模式使用 `:` 激活命令行后，`<C-r><C-w>` 把光标内容插到命令行提示中。

### 保存到寄存器

普通模式下，复制操作命令 `y` 保存内容到寄存器 `"` 和 `0`。而删除或更改操作 `x` `d`, `c` 保存到寄存器 `"` 和 `1` 到 `9`，滚动式地更新。可以看到，`"` 涉及 `yxdc` 都会改变，而 `0` 和 `1-9` 则有对应的操作。猜测，也许是因为滚动，vim 从中 undo。

`0` 是“安全复制寄存器”，不受删除操作影响。`1-9` 是删除历史寄存器，按操作顺序滚动更新。

指定保存的寄存器，先使用 `"<寄存器标识>`，再用 `yxdc` 其中之一，内容会保存到指定寄存器。普通模式和 visual 模式操作一致。

### 从寄存器中粘贴

指定保存的寄存器，先使用 `"<寄存器标识>`，再用 `p` 或 `P` 粘贴寄存器内容。可以总结，操作指定寄存器，使用 `"<reg#>` 即可。

插入模式下，使用 `<C-r><寄存器标识>`，比如 `<C-r>q` 将寄存器 `"q` 的内容粘贴。

## Macro：批量操作
Vim 中，宏可以记录用户的一组命令，并批量应用到多个位置或文件。

使用 `q<寄存器名>` 录制宏，后续按键操作记录到寄存器，再次按 `q` 停止。

输入 `@<寄存器名>` 播放宏，`@@` 使用上一次的宏。可以输入调用数量，比如 `5@a` 执行 5 次记录在寄存器 a 的宏。

如果需要将宏应用在选定区域的每一行，操作如下：
1. 选择 `V` 进入 visual 模式，后续选择多行即可
2. 进入命令模式，输入 `:` 时， 会自动出现 `:'<,'>`，代表正对选中区域操作。再输入 `normal @a`，可以看到最终输入 `:normal @a`，将寄存器 a 的宏应用到选中区域每一行

`normal` 代表执行普通模式下的操作。

### 查看宏

宏保存在寄存器中，可以用 `:reg` 查看所有寄存器的值，找到对应的即可。或直接查看单个寄存器，比如 q，`:reg q`。

### 例子

```cpp
    __device__ static void wgmma(uint64_t const& desc_a, uint64_t const& desc_b, float* d, bool scale_d) {
        wgmma(desc_a, desc_b,
              d[0], d[0], d[0], d[0], d[0], d[0], d[0], d[0],
              d[0], d[0], d[0], d[0], d[0], d[0], d[0], d[0],
              d[0], d[0], d[0], d[0], d[0], d[0], d[0], d[0],
              d[0], d[0], d[0], d[0], d[0], d[0], d[0], d[0],
              d[0], d[0], d[0], d[0], d[0], d[0], d[0], d[0],
              d[0], d[0], d[0], d[0], d[0], d[0], d[0], d[0],
              scale_d);
    }
```

修改方括号的数字，将上面的代码编辑为下面的。

```cpp
    __device__ static void wgmma(uint64_t const& desc_a, uint64_t const& desc_b, float* d, bool scale_d) {
        wgmma(desc_a, desc_b,
              d[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7],
              d[8], d[9], d[10], d[11], d[12], d[13], d[14], d[15],
              d[16], d[17], d[18], d[19], d[20], d[21], d[22], d[23],
              d[24], d[25], d[26], d[27], d[28], d[29], d[30], d[31],
              d[32], d[33], d[34], d[35], d[36], d[37], d[38], d[39],
              d[40], d[41], d[42], d[43], d[44], d[45], d[46], d[47],
              scale_d);
    }
```

```cpp
    __device__ static void wgmma(uint64_t const& desc_a, uint64_t const& desc_b, float* d, bool scale_d) {
        wgmma(desc_a, desc_b,
              d[0], d[0], d[0], d[0], d[0], d[0], d[0], d[0],
              d[0], d[0], d[0], d[0], d[0], d[0], d[0], d[0],
              d[0], d[0], d[0], d[0], d[0], d[0], d[0], d[0],
              d[0], d[0], d[0], d[0], d[0], d[0], d[0], d[0],
              d[0], d[0], d[0], d[0], d[0], d[0], d[0], d[0],
              d[0], d[0], d[0], d[0], d[0], d[0], d[0], d[0],
              scale_d);
    }
```

## Ref and Tag

#Vim
#Utils