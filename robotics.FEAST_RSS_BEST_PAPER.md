---
id: rxq64fy70h90d37wcx6ow99
title: FEAST_RSS_BEST_PAPER
desc: ''
updated: 1751822234332
created: 1751817663540
---

RSS 2025 Best Paper。用到了行为树。

好的，这是对论文 **FEAST: A Flexible Mealtime-Assistance System Towards In-the-Wild Personalization** 的总结。

## 论文总结

### 作者、团队信息、论文标题、论文链接、项目主页

*   **作者**: Rajat Kumar Jenamani, Tom Silver, Ben Dodson, et al., Tapomayukh Bhattacharjee
*   **团队信息**: 康奈尔大学 (Cornell University)，密歇根大学 (University of Michigan)，独立研究员
*   **论文标题**: FEAST: A Flexible Mealtime-Assistance System Towards In-the-Wild Personalization (FEAST: 一个面向真实世界个性化的灵活膳食辅助系统)
*   **论文链接**: [https://arxiv.org/abs/2506.14968v2](https://arxiv.org/abs/2506.14968v2)
*   **项目主页**: [http://emprise.cs.cornell.edu/feast](http://emprise.cs.cornell.edu/feast)

### 主要贡献

1.  **提出了 FEAST 系统**: 一个基于社区参与式研究 (community-based participatory research) 开发的灵活膳食辅助机器人系统。该系统集成了多样化的技能（喂食、喝水、擦嘴）、定制化工具和灵活的交互界面，以应对真实世界中的复杂场景。
2.  **完成了全面的用户需求研究**: 对 21 位具有不同身体障碍的护理接受者 (care recipients) 进行了形成性研究 (formative study)，识别了膳食辅助中多样化的个性化需求，并总结出三大关键原则：适应性 (adaptability)、透明性 (transparency) 和安全性 (safety)。
3.  **构建了一个创新的个性化框架**: 该框架基于三大原则，通过以下技术实现：
    *   **适应性**: 使用大型语言模型 (LLM) 将用户的自然语言指令转化为对参数化行为树 (Behavior Tree) 的安全修改，并能合成新的手势检测器。
    *   **透明性**: 符合 IEEE 透明度标准 (Levels 1-5)，利用 LLM 将系统的状态和行为变更以易于理解的语言总结给用户。
    *   **安全性**: 对齐 ISO/TS 13482 个人护理机器人安全标准，通过限制修改范围、静态检查和安全中心硬件设计来确保操作安全。
4.  **进行了深入的真实世界评估**: 与两名社区研究员 (community researchers) 合作，进行了为期五天的家庭内部署评估。在三种不同场景（个人用餐、看电视、社交）下完成了六顿真实膳食，验证了系统在真实环境中的可用性和个性化能力。此外，还通过职业治疗师 (Occupational Therapist) 的评估，进一步证实了其生态有效性 (ecological validity)。

### 研究背景（研究问题，研究难点和相关工作）

*   **研究问题**:
    全世界有数百万人因各种健康问题（如脊髓损伤、中风、多发性硬化症等）而需要他人协助进食。现有的机器人膳食辅助系统大多是“一刀切”的设计，难以满足不同用户在功能能力、行为偏好、饮食习惯和用餐环境（如独自用餐、社交用餐）上的巨大差异。因此，核心研究问题是如何设计一个能够“在真实世界 (in-the-wild)”中进行有效、安全、透明个性化的机器人膳食辅助系统。

*   **研究难点**:
    1.  **需求多样性**: 用户的身体能力、偏好和用餐场景千差万别，需要系统具备极高的灵活性和适应性。
    2.  **安全与适应性的平衡**: 允许用户修改系统行为会带来安全风险。如何在提供高度灵活性的同时，确保物理交互的绝对安全是一个巨大挑战。
    3.  **人机交互的透明性**: 用户需要理解机器人的行为逻辑，尤其是当行为被修改后。如何让非技术用户直观地理解和预测一个复杂系统的行为是关键。
    4.  **任务集成**: 真实的用餐过程不仅包括吃饭，还涉及喝水、擦嘴等。将这些任务无缝集成到一个系统中，并支持个性化，增加了系统复杂性。

*   **相关工作**:

| 领域研究                                | 已有方法                                                      | 局限性                                                                                    | 本文改进                                                                                                                            |
| :-------------------------------------- | :------------------------------------------------------------ | :---------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------- |
| **咬合获取 (Bite Acquisition)**         | FLAIR [20], Nanavati et al. [36]                              | 主要关注叉取 (skewering) 等有限技能；对食物种类和形态有限制。                             | 集成了叉取、舀取 (scooping)、蘸取 (dipping) 等多种技能；使用 LLM 动态排序技能序列，适应更多样化的食物。                             |
| **咬合转移 (Bite Transfer)**            | 外-口转移 (Outside-mouth) [23], 内-口转移 (Inside-mouth) [11] | 机器人动作可能遮挡用户视线，限制社交互动；工作空间受限。                                  | 采用新颖的垂直工具姿态和摄像头安装方式，扩大了工作空间，减少了遮挡，使社交互动更自然。                                              |
| **多任务集成 (Multi-task Integration)** | 大多数系统 [20, 23, 36] 专注于单一的喂食任务。                | 缺乏对喝水、擦嘴等真实用餐场景中其他必要任务的支持。                                      | **首次**将喂食、喝水、擦嘴等多种基本用餐任务集成到一个系统中，并通过工具自动更换来实现。                                            |
| **系统个性化 (System Personalization)** | Nanavati et al. [36], FLAIR [20]                              | 个性化选项是预定义的、有限的 (e.g., 调整速度)；缺乏开放式的用户定制能力；适应过程不透明。 | 提出基于 LLM 的开放式个性化框架，允许用户通过自然语言修改系统行为；过程透明，LLM 会向用户解释所做的修改；支持用户创建新的交互手势。 |

### 方法

FEAST 系统的设计围绕 **适应性、透明性、安全性** 三大原则。

1.  **系统硬件 (Hardware)**
    *   **核心**: Kinova Gen3 7-DoF 机械臂和 Robotiq 2F-85 夹爪，可灵活安装在轮椅或移动支架上。
    *   **模块化工具**: 设计了三种可由机器人自动更换的定制工具：
        1.  **喂食工具**: 集成电机，可实现类似手腕的动作（如旋转），前端的硅胶叉头可拆卸更换。
        2.  **喝水工具**: 一个适应性强的杯柄，可抓取不同形状的杯子。
        3.  **擦嘴工具**: 带有可更换的超细纤维布。
    *   **新颖的工具与相机朝向**: 工具与机械臂末端成 **90 度角安装**，模仿人手腕的自然姿态。RGB-D 相机也相应地侧向安装。这种设计扩大了机器人的工作空间，减少了对用户视线的遮挡。
    *   **交互硬件**: 配备了无障碍按钮、状态 LED 灯，方便用户在不同场景下进行交互和获取信息。

2.  **系统软件 (Software)**
    *   **技能表示**: 系统的所有技能（如抓取工具、获取食物）都被实现为**参数化的行为树 (Parameterized Behavior Trees)**。这种结构化表示允许系统在保证安全的前提下对技能的关键参数（如速度、等待时间）进行修改。
    *   **基于 LLM 的个性化流程**: 这是方法的核心。
        1.  **语言到结构化更新 (Language → Structured Updates)**: 用户通过网页界面输入自然语言指令（如“移动快一点”）。LLM (GPT-4o) 将该指令翻译成对行为树节点的具体参数修改。
        2.  **安全检查 (Safety Checks)**: 系统对 LLM 生成的修改指令进行静态检查，确保修改的节点和参数在预定义的、经过安全验证的范围内。
        3.  **更新结果到语言 (Update Results → Language)**: LLM 将已执行的修改和结果，用通俗的语言总结并反馈给用户，实现透明性。
    *   **手势合成 (Gesture Synthesis)**: 用户可通过界面提供几个新姿势的正反示例（如摇头），FEAST 利用 LLM 的代码合成能力生成一个定制化的、实时的手势检测器。
    *   **任务规划**: 使用 PDDL 规划器 (FastDownward) 将原子技能（如 `PickTool`, `AcquireBite`, `TransferTool`）序列化，以完成用户的复合指令（如“给我吃一口鸡块”）。

3.  **用户界面 (User Interface)**
    *   基于 Web 开发，可在平板或手机上访问，支持语音转文本输入。
    *   界面设计简洁，按钮尺寸大，易于操作。
    *   用户可以手动选择下一口食物，覆盖系统的自动推荐，增加了系统的鲁棒性。
    *   提供专门的**个性化页面**，用户可以在此输入自然语言指令来调整或查询系统行为。

### 实验与结论

*   **形成性研究 (Formative Study)**: 通过对 21 位护理接受者的研究，成功识别了 46 类个性化需求，并提炼出适应性、透明性和安全性三大设计原则，为 FEAST 的开发奠定了基础。

*   **真实世界评估 (In-the-Wild Evaluation)**:
    *   **设置**: 在两位社区研究员（CR1 和 CR2）的家中进行了为期 5 天的评估，涵盖了个人、看电视和社交三种真实用餐场景。
    *   **结果**:
        *   **高成功率**: 系统在不同食物和光照条件下表现出高鲁棒性，咬合获取成功率为 $$89.27\% \pm 9.24\%$$，咬合转移成功率为 $$93.07\% \pm 7.70\%$$。
        *   **有效的个性化**: 用户成功地根据自身需求和场景变化对系统进行了个性化调整（如调整速度、改变交互方式、静音等）。
        *   **低认知负荷**: NASA-TLX 调查显示，系统的平均认知负荷较低（CR1: 22.22, CR2: 7.41），远低于基线水平。
        *   **高接受度**: TAM 问卷结果显示，用户在感知有用性、易用性、使用意愿等方面给予了高度评价。与人类护理者相比，用户感觉对用餐过程有**更强的控制感和独立性**。

*   **职业治疗师评估 (OT Evaluation)**:
    *   一位不熟悉系统的职业治疗师成功地创建并完成了 10 个个性化场景，高度评价了系统的易用性和实用性，进一步验证了系统的生态有效性。

*   **结论 (Lessons Learned)**:
    1.  真实世界的用餐场景差异巨大，有效的个性化是系统成功的关键。
    2.  透明性至关重要，它帮助用户理解和迭代优化系统行为，即使用户的指令有时不被完美执行。
    3.  提供多种交互接口（网页、语音、按钮）对于适应不同情境和用户能力至关重要。
    4.  灵活性与用户参与是系统从现实世界故障中恢复的关键。

### 不足

1.  **开放集食物检测**: 系统依赖的物体检测器在识别盘子中多种混合食物时仍有困难，需要用户手动辅助修正。
2.  **基于盘子上下文的适应性有限**: 系统当前对某些操作（如蘸酱深度）使用单一参数，无法为同一盘中的不同食物（如鸡块和薯条）设置不同的蘸酱量。
3.  **LLM 幻觉**: 系统的核心个性化机制依赖 LLM，而 LLM 可能会产生幻觉或错误理解，导致适应失败或不完整，需要用户通过透明性功能来发现和纠正。
4.  **缺乏长期偏好学习**: 系统无法自动学习和迁移用户在某一场景下的个性化设置到新场景中，每次都需要重新或微调配置。
5.  **评估范围有限**: 主要评估对象是两位深度参与项目开发的社区研究员，他们对系统的熟悉度可能导致比普通用户更低的认知负荷。
6.  **开环技能的局限性**: 食物获取等技能是开环的，在食物滑落等意外情况下容易失败。

## QA

### 此工作如何应用行为树的？

好的，FEAST 系统中对**行为树 (Behavior Trees, BTs)** 的应用是其实现**适应性 (Adaptability)**、**安全性 (Safety)** 和 **透明性 (Transparency)** 这三大核心原则的关键技术手段。

以下是该工作如何应用行为树的具体方式：

#### 1. 将技能建模为“参数化的行为树”

这是最核心的思想。FEAST 系统中的每一个基本技能，例如 `AcquireBite` (获取食物)、`TransferTool` (转移工具)、`PickTool` (抓取工具) 等，都不是一个写死的、一成不变的程序，而是被建模成一个**参数化的行为树 (Parameterized Behavior Tree)**。

*   **什么是“参数化”？**
    研究人员将行为树中一些对用户体验至关重要的节点或逻辑的**关键参数“暴露”出来**，使其可以被外部（即用户通过 LLM）动态修改。

*   **具体例子：**
    论文中提到，`AcquireBite` (获取食物) 这个技能的行为树就暴露了至少三个参数：
    *   `Speed`: 机器人在执行此技能时的移动速度。
    *   `TimeToWaitBeforeAutocontinue`: 在自动执行下一口之前等待的时间。
    *   `AskUserForConfirmation`: 在获取食物后，是否需要向用户请求确认再进行下一步。

*   **安全值域 (Safety Domain):**
    为了保证安全，每一个暴露的参数都有一个预先定义好的、安全的值域。例如：
    *   `Speed` 的值域可能是 `{low, medium, high}`。
    *   `TimeToWaitBeforeAutocontinue` 的值域可能是 `[5, 100]` 秒。
    *   `AskUserForConfirmation` 的值域可能是 `{true, false}`。

通过这种方式，系统将原本黑盒的机器人行为，变成了一个可以被安全、可控地调整的“白盒”模块。

#### 2. 利用行为树实现安全、透明的个性化

当用户通过自然语言提出个性化请求时，行为树扮演了中间桥梁的角色：

1.  **语言到行为树的转换 (Adaptability & Safety)**:
    *   用户说：“你移动得太慢了，快一点”。
    *   LLM 将这个模糊的自然语言指令，精确地翻译成一个对行为树的结构化修改指令，例如：`Update BehaviorTree('AcquireBite', parameter='Speed', value='high')`。
    *   系统在应用这个修改前，会进行**安全检查**：检查 `high` 是否在 `Speed` 参数预设的安全值域内。只有通过检查，修改才会被应用。这确保了用户的任何修改都不会让机器人做出危险或未知的行为。

2.  **行为树到语言的解释 (Transparency)**:
    *   行为树的结构化特性使其易于被机器（LLM）和人理解。
    *   当用户询问“你为什么在这里停下了？”时，系统可以查询当前行为树的执行状态（例如，正处在一个 `AskUserForConfirmation` 节点并等待用户确认）。
    *   LLM 将这个结构化的状态信息，再次翻译成用户能听懂的自然语言：“我正在等待您的确认，然后才能将食物递给您。”

### 3. 行为树与高层任务规划 (PDDL) 的分工

FEAST 系统中，行为树和 PDDL (Planning Domain Definition Language) 协同工作，但职责分明：

*   **PDDL (高层规划器)**: 负责**“做什么” (What to do)**。它决定了为了完成一个用户目标（比如“吃一口饭”），需要以何种顺序调用哪些技能。它生成的是一个技能序列，例如：`Plan: PickTool -> AcquireBite -> TransferTool`。
*   **行为树 (底层执行逻辑)**: 负责**“怎么做” (How to do it)**。它定义了 PDDL 序列中的**每一个技能内部的具体执行逻辑和细节**。例如，`AcquireBite` 这个技能本身就是一个行为树，它包含了感知盘子、定位食物、执行舀取动作等一系列更细微的子动作。用户的个性化修改，正是作用在这些定义“怎么做”的行为树上。

**一个比喻：**
可以把 PDDL 看作是“菜谱”，告诉你先洗菜、再切菜、最后下锅炒。而行为树则是“下锅炒”这个步骤的具体说明，里面包含了“热锅（速度=快）”、“倒油（油量=3勺）”、“翻炒30秒”、“等待盐融化”等具体且可调整的细节。

### 总结

| 应用方面       | 具体实现方式                                                               | 带来的好处                                                                       |
| :------------- | :------------------------------------------------------------------------- | :------------------------------------------------------------------------------- |
| **技能表示**   | 每个技能都被建模为**参数化的行为树**，关键参数（如速度、时间）被暴露出来。 | 将复杂的机器人行为模块化、结构化，便于管理和修改。                               |
| **实现个性化** | 用户通过自然语言下达指令，LLM 将其翻译成对行为树参数的安全修改。           | 实现了**开放式、灵活**的个性化，超越了预设菜单的限制。                           |
| **保障安全性** | 所有可修改的参数都有**预定义的安全值域**，任何修改都需经过静态检查。       | 在提供高度灵活性的同时，确保了物理交互的安全性，解决了适应性与安全性的核心矛盾。 |
| **任务执行**   | PDDL 负责高层技能序列规划，行为树负责每个技能的底层、可定制化的执行。      | 实现了复杂任务的**分层控制**，使得系统既有规划能力，又有灵活的执行细节。         |

综上所述，FEAST 系统巧妙地将参数化的行为树作为连接高层语言指令和底层机器人控制的桥梁，从而在一个统一的框架内，优雅地实现了适应性、安全性和透明性这三个看似矛盾的目标。

### 详细介绍 PDDL

好的，非常乐意为您详细介绍 PDDL。PDDL 是 AI 规划领域一个非常基础且重要的概念，理解它对于看懂很多机器人或自动化相关的论文非常有帮助。

PDDL 结合 LLM 在最近会议出现频率较高。

---

## PDDL (Planning Domain Definition Language) 详解

### 1. 什么是 PDDL？

**PDDL** 的全称是**规划领域定义语言 (Planning Domain Definition Language)**。你可以把它理解为**AI 规划领域的“SQL”**。

*   **它的目标是**：提供一个标准化的、统一的语言来描述一个“规划问题”，使得研究人员可以专注于开发更高效的“规划器 (Planner)”算法，而不用为每个问题都重新定义一套描述格式。
*   **核心思想**：将一个规划问题严格地拆分为两个部分：
    1.  **世界的规则 (The Physics of the World)**：什么动作是可能的？做这些动作需要满足什么条件？做了之后世界会发生什么变化？
    2.  **具体的情景 (A Specific Scenario)**：当前世界是什么样子？我们想要达到的目标是什么？

这种分离带来了极大的灵活性和重用性。

### 2. PDDL 的核心组成部分：Domain 和 Problem

一个完整的 PDDL 规划问题通常由两个文本文件组成：

#### A. 领域文件 (Domain File) - 定义规则

这个文件描述了“世界是如何运作的”，它定义了所有可能发生的事情。可以把它想象成一个游戏的**规则手册**。

它主要包含以下几个部分：

*   `(:requirements)`：声明将使用 PDDL 的哪些特性。最常见的是 `:strips`，它代表了经典的 STRIPS 规划范式（后面会解释）。
*   `(:types)`：定义世界中物体的**类型**。例如，`robot`、`location`、`food`。这有助于让模型更清晰、更严谨。
*   `(:predicates)`：定义**谓词**，也就是可以为“真”或“假”的状态。它们描述了世界中的事实。例如：
    *   `(at ?r - robot ?l - location)`：表示机器人 `?r` 在位置 `?l`。
    *   `(holding ?r - robot ?i - item)`：表示机器人 `?r` 正拿着物品 `?i`。
    *   *（`?` 开头的变量是参数，`-` 后面是其类型）*
*   `(:action)`：**这是领域文件的核心**，定义了可以执行的**动作**。每个动作都包含：
    *   **`:parameters`**：执行该动作需要哪些对象（及其类型）。
    *   **`:precondition`**：**前置条件**。一个逻辑表达式，必须为“真”时，该动作才能被执行。
    *   **`:effect`**：**效果**。描述了动作执行后，世界的状态会发生什么变化。通常是一些谓词变为“真”，一些变为“假”。

#### B. 问题文件 (Problem File) - 定义情景

这个文件描述了一个**具体的任务实例**。可以把它想象成一盘棋的**初始布局和获胜目标**。

它主要包含以下几个部分：

*   `(:domain)`：声明此问题文件是基于哪个领域文件定义的。
*   `(:objects)`：列出这个具体问题中存在的所有**物体实例**。例如：
    *   `robot1 - robot`
    *   `kitchen bedroom - location`
*   `(:init)`：**初始状态**。一个谓词列表，描述了世界一开始是什么样子。所有在此列出的谓词初始为“真”，未列出的则为“假”。
*   `(:goal)`：**目标状态**。一个逻辑表达式，描述了我们想要达到的最终状态。当这个表达式为“真”时，规划就成功了。

---

### 3. 一个简单的例子：机器人送货

**场景**：一个机器人在厨房，需要把一个包裹送到卧室。

#### 领域文件: `delivery-domain.pddl`

```pddl
(define (domain delivery-robot)
  (:requirements :strips :typing)

  (:types ; 定义类型
    robot package location
  )

  (:predicates ; 定义状态
    (at ?obj - (either robot package) ?loc - location) ; 物体在某地
    (holding ?r - robot ?p - package)                ; 机器人拿着包裹
    (free ?r - robot)                                ; 机器人手上是空的
  )

  (:action move ; 定义“移动”动作
    :parameters (?r - robot ?from - location ?to - location)
    :precondition (and (at ?r ?from) (free ?r)) ; 前提：机器人必须在出发点，并且手上是空的
    :effect (and (at ?r ?to) (not (at ?r ?from))) ; 效果：机器人到了新地点，并且不再在旧地点
  )

  (:action pickup ; 定义“捡起”动作
    :parameters (?r - robot ?p - package ?loc - location)
    :precondition (and (at ?r ?loc) (at ?p ?loc) (free ?r)) ; 前提：机器人和包裹在同一地点，且机器人手是空的
    :effect (and (holding ?r ?p) (not (at ?p ?loc)) (not (free ?r))) ; 效果：机器人拿着包裹，包裹不再在地上，机器人手不再是空的
  )

  (:action dropoff ; 定义“放下”动作
    :parameters (?r - robot ?p - package ?loc - location)
    :precondition (and (at ?r ?loc) (holding ?r ?p)) ; 前提：机器人在目标地点，并且正拿着包裹
    :effect (and (at ?p ?loc) (free ?r) (not (holding ?r ?p))) ; 效果：包裹在新地点，机器人手空了，机器人不再拿着包裹
  )
)
```

#### 问题文件: `delivery-problem.pddl`

```pddl
(define (problem deliver-the-package)
  (:domain delivery-robot) ; 关联到上面的领域

  (:objects ; 定义具体的物体
    robot1 - robot
    package1 - package
    kitchen bedroom - location
  )

  (:init ; 定义初始状态
    (at robot1 kitchen)
    (at package1 kitchen)
    (free robot1)
  )

  (:goal ; 定义目标状态
    (at package1 bedroom)
  )
)
```

#### 4. 规划器的工作流程

1.  **输入**：将上述的 `delivery-domain.pddl` 和 `delivery-problem.pddl` 文件提供给一个**AI 规划器** (例如 FEAST 论文中使用的 FastDownward)。
2.  **搜索**：规划器会分析这两个文件，理解世界的规则、初始状态和目标。然后，它会通过复杂的搜索算法（如启发式搜索、前向搜索等）在巨大的可能状态空间中寻找一条从 `(:init)` 到 `(:goal)` 的路径。
3.  **输出**：如果找到路径，规划器会输出一个**计划 (Plan)**，这是一个具体的、可执行的动作序列。对于上面的例子，输出的计划可能是：
    ```
    (pickup robot1 package1 kitchen)
    (move robot1 kitchen bedroom)
    (dropoff robot1 package1 bedroom)
    ```

这个计划随后可以被一个机器人的**执行控制器**拿去，一步步地执行。

#### 5. PDDL 的优缺点

**优点**:

*   **标准化**：最大的优点，促进了不同规划器之间的公平比较和复用。
*   **声明式 (Declarative)**：你只需要描述“是什么”和“要什么”，而不用关心“怎么做”，规划器会帮你找出方法。
*   **模块化和可重用性**：领域文件可以被多个不同的问题文件重用。
*   **强大的生态系统**：有大量现成的、高效的规划器可供使用。

**缺点**:

*   **确定性世界 (Determinism)**：经典的 STRIPS 范式假设动作的效果是确定的、完美的。这在真实的机器人世界中往往不成立（动作可能失败）。（*有扩展如 PPDDL 用于处理概率*）
*   **瞬时动作 (Instantaneous Actions)**：基本 PDDL 中，动作没有持续时间，是瞬间完成的。（*有扩展如 Temporal PDDL 用于处理时间*）
*   **离散状态**：世界由一系列真/假命题描述，难以建模连续值（如电池电量、温度）。
*   **可伸缩性问题**：对于非常复杂的问题，状态空间会呈指数级爆炸，规划器可能找不到解或耗时极长。

### 在 FEAST 论文中的应用

在 FEAST 系统中，PDDL 的角色非常清晰：**高层任务规划**。

*   它的**动作 (`:action`)** 不是底层的电机控制，而是上层的**技能 (Skills)**，如 `PickTool(utensil)`、`AcquireBite(utensil)`。
*   当用户请求“吃一口”时，系统的目标 (`:goal`) 就被设置为与“用户完成一次咬合”相关的状态。
*   PDDL 规划器 (FastDownward) 会生成一个技能序列计划，例如 `(PickTool utensil) -> (AcquireBite utensil) -> (TransferTool utensil)`。
*   这个计划告诉系统**应该按什么顺序调用哪些技能**。
*   而**每个技能内部的具体执行方式**（比如 `AcquireBite` 是快是慢，是舀还是叉），则由该技能对应的**行为树 (Behavior Tree)** 来负责。

这种 **PDDL (管“做什么”) + 行为树 (管“怎么做”)** 的分层架构，使得系统既有清晰的逻辑规划能力，又有灵活的底层执行细节，是现代机器人系统中一种非常经典和有效的设计模式。

## Ref and Tag

[主页](https://emprise.cs.cornell.edu/feast/)

https://arxiv.org/abs/2506.14968